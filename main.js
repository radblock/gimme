'use strict'

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * SETUP
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

const aws = require('aws-sdk')
const s3 = new aws.S3()
const ses = new aws.SES()

const random_word = require('random-word')

const crypto = require('crypto')

const js_schema = require('js-schema')

const ApiBuilder = require('claudia-api-builder')
const api = new ApiBuilder()
module.exports = api

// const deps = require('./deps.json')
const deps = {
  'user_bucket': 'radblock-users',
  'bucket': 'gifs.radblock.xyz',
  'pending_bucket': 'radblock-pending-gifs',
  'my_url': 'https://qcwrvld7k9.execute-api.us-east-1.amazonaws.com/latest/'
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * CRYPTO
 *
 * https://gist.github.com/skeggse/52672ddee97c8efec269
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

const passwords = (function () {
  // larger numbers mean better security, less
  const config = {
    // size of the generated hash
    hashBytes: 32,
    // larger salt means hashed passwords are more resistant to rainbow table, but
    // you get diminishing returns pretty fast
    saltBytes: 16,
    // more iterations means an attacker has to take longer to brute force an
    // individual password, so larger is better. however, larger also means longer
    // to hash the password. tune so that hashing the password takes about a
    // second
    iterations: 10000
  }

  /**
   * Hash a password using Node's asynchronous pbkdf2 (key derivation) function.
   *
   * Returns a self-contained buffer which can be arbitrarily encoded for storage
   * that contains all the data needed to verify a password.
   *
   * @param {!String} password
   * @param {!function(?Error, ?Buffer=)} callback
   */
  const hash = function (password) {
    return new Promise(function (resolve, reject) {
      console.log('making a hash')
      // generate a salt for pbkdf2
      crypto.randomBytes(config.saltBytes, function (err, salt) {
        if (err) { reject('error making random bytes') }

        console.time('hashing')
        return crypto.pbkdf2(password, salt, config.iterations, config.hashBytes, function (err, hash) {
          console.timeEnd('hashing')
          if (err) { return reject('error pbkdf2-ing') }

          let combined = new Buffer(hash.length + salt.length + 8)

          // include the size of the salt so that we can, during verification,
          // figure out how much of the hash is salt
          combined.writeUInt32BE(salt.length, 0, true)
          // similarly, include the iteration count
          combined.writeUInt32BE(config.iterations, 4, true)

          salt.copy(combined, 8)
          hash.copy(combined, salt.length + 8)
          const string = combined.toString('base64')
          return resolve(string)
        })
      })
    })
  }

  /**
   * Verify a password using Node's asynchronous pbkdf2 (key derivation) function.
   *
   * Accepts a hash and salt generated by hashPassword, and returns whether the
   * hash matched the password (as a boolean).
   *
   * @param {!String} password
   * @param {!Buffer} combined Buffer containing hash and salt as generated by
   *   hashPassword.
   * @param {!function(?Error, !boolean)}
   */
  const verify = function (password, combined_string) {
    return new Promise(function (resolve, reject) {
      const combined = new Buffer(combined_string, 'base64')
      // extract the salt and hash from the combined buffer
      const saltBytes = combined.readUInt32BE(0)
      const hashBytes = combined.length - saltBytes - 8
      const iterations = combined.readUInt32BE(4)
      const salt = combined.slice(8, saltBytes + 8)
      const hash = combined.toString('binary', saltBytes + 8)

      // verify the salt and hash against the password
      console.time('verifying')
      crypto.pbkdf2(password, salt, iterations, hashBytes, function (err, verify) {
        console.timeEnd('verifying')
        if (err) { return reject('err pbkdf2-ing') }
        if (verify.toString('binary') === hash) {
          return resolve(true)
        } else {
          return reject('passwords don\'t match')
        }
      })
    })
  }

  return Object.freeze({
    verify,
    hash
  })
})()

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * API
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

api.post('/submit', function (request) {
  console.log('hit submit endpoint')
  validate({
    email: String,
    password: String,
    filename: String
  }, request.body)
  return new Promise(function (resolve, reject) {
    return go_create_or_find_user(request.body)
           .then(randomize_filename)
           .then(go_save_user)
           .then(go_handle_upload)
           .then(go_validate({
             signed_request: String,
             bucket: [deps.bucket, deps.pending_bucket],
             key: String
           }))
           .then(resolve)
           .catch(function () {
             return reject({
               'status': 'failure'
             })
           })
  })
})

api.post('/verify', function (request) {
  console.log('hit verify endpoint')
  validate({
    email: String,
    code: String
  }, request.body)
  return new Promise(function (resolve, reject) {
    return go_verify_user(request.body)
           .then(go_unpend)
           .then(go_save_user)
           .then(function () {
             return resolve({
               'status': 'success'
             })
           })
           .catch(function () {
             return reject({
               'status': 'failure'
             })
           })
  })
})

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * FUNCTIONS
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

function go_check_password (user) {
  console.log('checking user password')
  validate({
    password: String,
    kdf: String
  }, user)
  return new Promise(function (resolve, reject) {
    return passwords.verify(user.password, user.kdf)
           .then(function () {
             delete user.password
             return resolve(user)
           })
           .catch(reject)
  })
}

function go_handle_upload (user) {
  console.log('handling upload')
  validate({
    gif_key: String,
    state: ['ready', 'pending', 'rate-limited', 'banned']
  }, user)
  return new Promise(function (resolve, reject) {
    switch (user.state) {
      case 'ready':
        go_rate_limit(user)
        go_charge_card(user)
        return go_get_signed_url_for(deps.bucket, user)
               .then(resolve)
               .catch(reject)

      case 'pending':
        go_rate_limit(user)
        go_charge_card(user)
        return go_get_signed_url_for(deps.pending_bucket, user)
               .then(resolve)
               .catch(reject)

      case 'rate-limited':
        return reject('you already uploaded a gif today.')

      case 'banned':
        return reject('you are banned.')
    }
  })
}

function go_unpend (user) {
  console.log('unpending')
  validate({
    gif_key: String
  }, user)
  return new Promise(function (resolve, reject) {
    // move the user's pending gif into the regular bucket
    return s3.copyObject({
      Bucket: deps.bucket,
      Key: user.gif_key,
      CopySource: `${deps.pending_bucket}/${user.gif_key}`
    }, function (err, data) {
      if (err) { return reject(err) }
      return resolve(user)
    })
  })
}

function go_rate_limit (user) {
  console.log('rate limiting')
  return new Promise(function (resolve, reject) {
    user.state = 'rate-limited'
    return resolve(user)
  })
}

function go_charge_card (user) {
  console.log('charging card')
  return new Promise(function (resolve, reject) {
    // TODO: write this
    return resolve(user)
  })
}

function go_get_signed_url_for (bucket, user) {
  console.log('getting signed url')
  validate(String, bucket)
  validate({
    gif_key: String
  }, user)
  return new Promise(function (resolve, reject) {
    return s3.getSignedUrl('putObject', {
      Bucket: bucket,
      Key: user.gif_key,
      ContentType: 'image/gif',
      ACL: 'public-read'
    }, function (err, data) {
      if (err) { return reject(err) }
      return resolve({
        signed_request: data,
        bucket: bucket,
        key: user.gif_key
      })
    })
  })
}

function go_create_or_find_user (request) {
  console.log('finding or creating a user')
  validate({
    email: String,
    password: String
  }, request)
  return new Promise(function (resolve, reject) {
    go_get_user(request)
    .catch(function (reason) {
      if (reason === 'bad password') {
        return reject('bad password')
      }
      go_create_user(request)
      .then(resolve)
    })
    .then(resolve)
  })
}

function go_verify_user (request) {
  console.log('verifying a user')
  validate({
    email: String,
    code: String
  }, request)
  return new Promise(function (resolve, reject) {
    go_get_user(request.email)
    .then(function (user) {
      if (user.code === request.code) {
        return resolve(user)
      }
      return reject(user)
    })
    .catch(reject)
  })
}

function go_create_user (request) {
  console.log('creating a user')
  validate({
    email: String,
    password: String,
    filename: String
  }, request)
  return new Promise(function (resolve, reject) {
    let promises = [
      go_send_code(request),
      passwords.hash(request.password)
    ]
    Promise.all(promises)
    .then(function (vals) {
      console.log('got back', vals)
      let user = vals[0]
      const kdf = vals[1]

      user.state = 'pending'
      user.kdf = kdf
      delete user.password
      resolve(user)
    })
  })
}

function go_get_user (request) {
  console.log('getting a user')
  validate({
    email: String,
    password: String
  }, request)
  return new Promise(function (resolve, reject) {
    return s3.getObject({
      Bucket: deps.user_bucket,
      Key: request.email
    }, function (err, data) {
      if (err) { console.log('user does not exist', err); return reject(request) }
      let user = merge(request, JSON.parse(data.Body))
      return go_check_password(user)
             .then(resolve)
             .catch(function () {
               return reject('bad password')
             })
    })
  })
}

function go_save_user (user) {
  console.log('saving a user')
  validate({
    email: String
  }, user)
  return new Promise(function (resolve, reject) {
    return s3.putObject({
      Bucket: deps.user_bucket,
      Key: user.email,
      Body: JSON.stringify(user)
    }, function (err, data) {
      if (err) { return reject(err) }
      return resolve(user)
    })
  })
}

function gen_random_string (length) {
  const s = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
  return Array.apply(null, Array(length))
    .map(function () {
      return s.charAt(Math.floor(Math.random() * s.length))
    }).join('')
}

function randomize_filename (user) {
  console.log('randomizing a user\'s filename')
  validate({
    filename: String
  }, user)
  user.gif_key = gen_random_string(4) + '-' + gen_random_string(4) + '/' + user.filename
  delete user.filename
  return new Promise(function (resolve, reject) {
    return resolve(user)
  })
}

function validate (schema, input) {
  console.log('validating', input)
  const Schema = js_schema(schema)
  if (Schema(input)) {
    return true
  } else {
    throw new TypeError('failed validation')
  }
}

function go_send_code (user) {
  console.log('sending a code')
  validate({
    email: String,
    filename: String
  }, user)
  return new Promise(function (resolve, reject) {
    user.code = [1, 2, 3].map(random_word).join('-')
    const text = `visit ${deps.my_url}/verify?email=${user.email}&code=${user.code} to finish uploading ${user.filename}`
    var params = {
      Destination: {
        ToAddresses: [ user.email ]
      },
      Message: {
        Body: {
          Html: {
            Data: text,
            Charset: 'UTF-8'
          },
          Text: {
            Data: text,
            Charset: 'UTF-8'
          }
        },
        Subject: {
          Data: 'verify your email address for radblock',
          Charset: 'UTF-8'
        }
      },
      Source: 'system@radblock.xyz'
    }
    ses.sendEmail(params, function (err, data) {
      console.log('tried to send email', err, data)
      if (err) { return reject('failed to send email') }
      console.log('send email. code is', user.code)
      resolve(user)
    })
  })
}

function go_validate (schema) {
  return function (input) {
    return new Promise(function (resolve, reject) {
      const is_validated = validate(schema, input)
      if (is_validated) {
        return resolve(input)
      } else {
        return reject(input)
      }
    })
  }
}

function merge (a, b) {
  let c = {}
  for (let attrname in a) { c[attrname] = a[attrname] }
  for (let attrname in b) { c[attrname] = b[attrname] }
  return c
}

