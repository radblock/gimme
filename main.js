'use strict'

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * SETUP
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

const aws = require('aws-sdk')
const s3 = new aws.S3()

const crypto = require('crypto')

const js_schema = require('js-schema')

const ApiBuilder = require('claudia-api-builder')
const api = new ApiBuilder()
module.exports = api

// const deps = require('./deps.json')
const deps = {
  'user_bucket': 'radblock-users',
  'bucket': 'gifs.radblock.xyz',
  'pending_bucket': 'radblock-pending-gifs'
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * CRYPTO
 *
 * https://gist.github.com/skeggse/52672ddee97c8efec269
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

const passwords = (function () {
  // larger numbers mean better security, less
  const config = {
    // size of the generated hash
    hashBytes: 32,
    // larger salt means hashed passwords are more resistant to rainbow table, but
    // you get diminishing returns pretty fast
    saltBytes: 16,
    // more iterations means an attacker has to take longer to brute force an
    // individual password, so larger is better. however, larger also means longer
    // to hash the password. tune so that hashing the password takes about a
    // second
    iterations: 872
  }

  /**
   * Hash a password using Node's asynchronous pbkdf2 (key derivation) function.
   *
   * Returns a self-contained buffer which can be arbitrarily encoded for storage
   * that contains all the data needed to verify a password.
   *
   * @param {!String} password
   * @param {!function(?Error, ?Buffer=)} callback
   */
  const hash = function (password) {
    return new Promise(function (resolve, reject) {
      // generate a salt for pbkdf2
      crypto.randomBytes(config.saltBytes, function (err, salt) {
        if (err) { reject('error making random bytes') }

        crypto.pbkdf2(password, salt, config.iterations, config.hashBytes, function (err, hash) {
          if (err) { reject('error pbkdf2-ing') }

          let combined = new Buffer(hash.length + salt.length + 8)

          // include the size of the salt so that we can, during verification,
          // figure out how much of the hash is salt
          combined.writeUInt32BE(salt.length, 0, true)
          // similarly, include the iteration count
          combined.writeUInt32BE(config.iterations, 4, true)

          salt.copy(combined, 8)
          hash.copy(combined, salt.length + 8)
          const string = combined.toString('base64')
          console.log('crypto hash', '|++|', string)
          resolve(string)
        })
      })
    })
  }

  /**
   * Verify a password using Node's asynchronous pbkdf2 (key derivation) function.
   *
   * Accepts a hash and salt generated by hashPassword, and returns whether the
   * hash matched the password (as a boolean).
   *
   * @param {!String} password
   * @param {!Buffer} combined Buffer containing hash and salt as generated by
   *   hashPassword.
   * @param {!function(?Error, !boolean)}
   */
  const verify = function (password, combined_string) {
    console.log('crypto verify', password, '|++|', combined_string)
    return new Promise(function (resolve, reject) {
      console.log('0')
      const combined = new Buffer(combined_string, 'base64')
      // extract the salt and hash from the combined buffer
      console.log('1')
      const saltBytes = combined.readUInt32BE(0)
      console.log('2')
      const hashBytes = combined.length - saltBytes - 8
      console.log('3')
      const iterations = combined.readUInt32BE(4)
      console.log('4')
      const salt = combined.slice(8, saltBytes + 8)
      console.log('5')
      const hash = combined.toString('binary', saltBytes + 8)

      // verify the salt and hash against the password
      console.log('6')
      crypto.pbkdf2(password, salt, iterations, hashBytes, function (err, verify) {
        console.log('7')
        if (err) { reject('err pbkdf2-ing') }
        console.log('8')
        if (verify.toString('binary') === hash) {
          console.log('9')
          resolve(true)
        } else {
          console.log('10')
          reject('passwords don\'t match')
        }
      })
    })
  }

  return Object.freeze({
    verify,
    hash
  })
})()

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * API
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

api.post('/submit', function (request) {
  console.log('hit submit endpoint')
  validate({
    email: String,
    password: String,
    filename: String
  }, request.body)
  return new Promise(function (resolve, reject) {
    return go_create_or_find_user(request.body)
           .then(randomize_filename)
           .then(go_save_user)
           .then(go_handle_upload)
           .then(go_validate({
             signed_request: String,
             bucket: [deps.bucket, deps.pending_bucket],
             key: String
           }))
           .then(resolve)
           .catch(function () {
             reject({
               'status': 'failure'
             })
           })
  })
})

api.post('/verify', function (request) {
  console.log('hit verify endpoint')
  validate({
    email: String,
    code: String
  }, request.body)
  return new Promise(function (resolve, reject) {
    return go_verify_user(request.body)
           .then(go_unpend)
           .then(go_save_user)
           .then(function () {
             resolve({
               'status': 'success'
             })
           })
           .catch(function () {
             reject({
               'status': 'failure'
             })
           })
  })
})

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * FUNCTIONS
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

function go_check_password (user) {
  console.log('checking user password')
  validate({
    password: String,
    kdf: String
  }, user)
  return new Promise(function (resolve, reject) {
    passwords.verify(user.password, user.kdf)
      .then(function () {
        user.password = undefined
        resolve(user)
      })
      .catch(reject)
  })
}

function go_handle_upload (user) {
  console.log('handling upload')
  validate({
    gif_key: String,
    state: ['ready', 'pending', 'rate-limited', 'banned']
  }, user)
  return new Promise(function (resolve, reject) {
    switch (user.state) {
      case 'ready':
        go_rate_limit(user)
        go_charge_card(user)
        return go_get_signed_url_for(deps.bucket, user)
               .then(resolve)
               .catch(reject)

      case 'pending':
        go_rate_limit(user)
        go_charge_card(user)
        return go_get_signed_url_for(deps.pending_bucket, user)
               .then(resolve)
               .catch(reject)

      case 'rate-limited':
        return reject('you already uploaded a gif today.')

      case 'banned':
        return reject('you are banned.')
    }
  })
}

function go_unpend (user) {
  console.log('unpending')
  validate({
    gif_key: String
  }, user)
  return new Promise(function (resolve, reject) {
    // move the user's pending gif into the regular bucket
    s3.copyObject({
      Bucket: deps.bucket,
      Key: user.gif_key,
      CopySource: `${deps.pending_bucket}/${user.gif_key}`
    }, function (err, data) {
      if (err) { return reject(err) }
      return resolve(user)
    })
  })
}

function go_rate_limit (user) {
  console.log('rate limiting')
  return new Promise(function (resolve, reject) {
    user.state = 'rate-limited'
    return resolve(user)
  })
}

function go_charge_card (user) {
  console.log('charging card')
  return new Promise(function (resolve, reject) {
    // TODO: write this
    return resolve(user)
  })
}

function go_get_signed_url_for (bucket, user) {
  console.log('getting signed url')
  validate(String, bucket)
  validate({
    gif_key: String
  }, user)
  return new Promise(function (resolve, reject) {
    s3.getSignedUrl('putObject', {
      Bucket: bucket,
      Key: user.gif_key,
      ContentType: 'image/gif',
      ACL: 'public-read'
    }, function (err, data) {
      if (err) { return reject(err) }
      return resolve({
        signed_request: data,
        bucket: bucket,
        key: user.gif_key
      })
    })
  })
}

function go_create_or_find_user (request) {
  console.log('finding or creating a user')
  validate({
    email: String,
    password: String
  }, request)
  return new Promise(function (resolve, reject) {
    go_get_user(request)
      .catch(function (reason) {
        if (reason === 'bad password') {
          return reject('bad password')
        }
        return go_create_user(request)
      })
      .then(resolve)
  })
}

function go_verify_user (request) {
  console.log('verifying a user')
  validate({
    email: String,
    code: String
  }, request)
  return new Promise(function (resolve, reject) {
    go_get_user(request.email)
      .then(function (user) {
        if (user.code === request.code) {
          return resolve(user)
        }
        return reject(user)
      })
      .catch(reject)
  })
}

function go_create_user (request) {
  console.log('creating a user')
  validate({
    email: String,
    password: String,
    filename: String
  }, request)
  return new Promise(function (resolve, reject) {
    // TODO send email
    request.state = 'pending'
    request.code = '12345'
    passwords.hash(request.password)
      .then(function (kdf) {
        request.kdf = kdf
        request.password = undefined
        resolve(request)
      })
  })
}

function go_get_user (request) {
  console.log('getting a user')
  validate({
    email: String,
    password: String
  }, request)
  return new Promise(function (resolve, reject) {
    s3.getObject({
      Bucket: deps.user_bucket,
      Key: request.email
    }, function (err, data) {
      if (err) { console.log('user does not exist', err); return reject(request) }
      let user = JSON.parse(data.Body)
      user.password = request.password
      go_check_password(user)
        .then(resolve)
        .catch(function () {
          reject('bad password')
        })
    })
  })
}

function go_save_user (user) {
  console.log('saving a user')
  validate({
    email: String
  }, user)
  return new Promise(function (resolve, reject) {
    s3.putObject({
      Bucket: deps.user_bucket,
      Key: user.email,
      Body: JSON.stringify(user)
    }, function (err, data) {
      if (err) { return reject(err) }
      return resolve(user)
    })
  })
}

function gen_random_string (length) {
  const s = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
  return Array.apply(null, Array(length))
    .map(function () {
      return s.charAt(Math.floor(Math.random() * s.length))
    }).join('')
}

function randomize_filename (user) {
  console.log('randomizing a user\'s filename')
  validate({
    filename: String
  }, user)
  user.gif_key = gen_random_string(4) + '-' + gen_random_string(4) + '/' + user.filename
  user.filename = undefined
  return new Promise(function (resolve, reject) {
    resolve(user)
  })
}

function validate (schema, input) {
  console.log('validating', input)
  const Schema = js_schema(schema)
  if (Schema(input)) {
    return true
  } else {
    throw new TypeError('failed validation')
  }
}

function go_validate (schema) {
  return function (input) {
    return new Promise(function (resolve, reject) {
      const is_validated = validate(schema, input)
      if (is_validated) {
        resolve(input)
      } else {
        reject(input)
      }
    })
  }
}

